Lesson 4:
Remix FundMe
We're going to create a crowdfunding type program called FundMe where users can pay in cryptocurrency to fund a cause.
This contract will allow the owner of the contract to withdraw the funds.
A new item we'll see in this lesson is a payable function (indicated by a red button in remix)
this allows the contract in question to be sent the native gas token of the chain you're working with is.
We'll also indicate a minimum USD amount in the contract.

When writing a contract or app lay out an outline of what each contract is supposed to do.
Study the global keywordsand functions!!!!!!!!!!!!!

Whenever we transact on the blockchain, there is always a value field and usually it is sent with 0 as the value. 

When we send ethereum to another wallet, we are actually putting the amount we're sending in the value field in a transaction

To make it so a user can send value to a contract, we need to add the payable keyword as such:

function fund() public payable {}

Contracts can hold funds just like a wallet address can.

We are going to use the msg.value global function to include a number of wei sent with the message.

along with including the function that allows eth to be sent to the contract, let's include code that requires a minimum amount of eth to be sent to the contract with the require as such. We will also include code that gives a message if the transaction is reverted:

require(msg.value > 1e18, didn't send enough eth);

This means that at a minimum, for this message to interact with the contract it must send a value of 1 ethereum. And the requires plus the comma indicate if the first portion reverts, do whatever the second portion says.

1e18= 1 eth = 1*10^18 wei

-------------------------------
Reverts:

Undo any actions that have been done previously, and sends the remaining gas back to user.

Let's add some logic in to see how reverts work:

let's add in uint256 public myValue = 1; //declared at the beginning of the contract

and
myValue = myValue + 2;//within the contract.

What this does is add 2 to the myValue variable every time this contract is successfully funded.

STUDY all the transaction fields!
-----------------==========================
Integrating chainlink price feeds:
Let's say in the contract we want users to spend a minimum of 5$ instead of 1 whole ethereum.
first we'll declare the minimumUsd value at the beginning of the contract:

uint8 minimumUsd = 5;

Then we change the require msg value to our new variable:

require(msg.value >= minimumUsd, "didn't send enough eth")

now, msg.value is in terms of eth but minimum USD is in terms of dollars.
To get the value of eth in dollars, we'll need to use a chainlink price data feed:

the next step will be to convert the amount of ethereum into it's value in dollars.

first we'll create a function to get the ethereum usd price, then get the conversion rate to compare it to the payable function above to see if the minimum 5 dollar threshold was met
Just as any other contract call, when we call the contract that coordinates the chainlink eth/usd price data feed we will need to find 2 datapoints:

function getPrice public(){
	// Eth USD price contract Address: 0x694AA1769357215DE4FAC081bf1f309aDC325306
	
	// ABI: When we import/call a contract, the ABI is imported but that brings in a lot of extra unnecessary code. Instead we can call the latestround function in particular to grab the price data.
}
function getConversionRate public(){

}

There will be instances where code acts as just an interface, without any logic included within it as shown by the aggregatorv3interface that lives at https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/interfaces/FeedRegistryInterface.sol
Think of the interface as being the remote control that has the commands, and the contract it points to (in this case the eth/usd data feed contract on sepolia) being the TV that processes and has all the components to execute the command from the remote.

If you compile the interface, it will give you the ABIs you need to interact with an address.

Next let's add a function that calls the getVersion function from the aggregator interface:

function getVersion() public view returns (uint256){
	AggregatorV3Interface(0x694AA1769357215DE4FAC081bf1f309aDC325306).version();
}

https://youtu.be/umepbfKp5rI?t=16733

-------------------------===============================--

Previously we imported a contract into another contract, but both contracts lived locally in remix. Let's replace the cumbersome interface code we copy pasted into the fundMe contract with something that works a little leaner.

importing external contracts:
we are using NAMED imports, because we only want to pull over exactly what we're using to save on gas!

import {AggregatorV3Interface} from "@chainlink/contracts/src/v0.8/shared/interfaces/AggregatorV3Interface.sol"

Now that we've imported the particular code we need, let's create a function to pull chainlink price feed data into a smart contract:

function getPrice() public {
//Address - 
//ABI - 
AggregatorV3Interface priceFeed = AggregatorV3Interface(0x694AA1769357215DE4FAC081bf1f309aDC325306)}
(, int price,,,) = priceFeed.latestRoundData() //the price variable represents the price of eth in usd. We can omit the variables we don't need, but must keep the commas from them. In doing this, we are only assigning return value to the price variable, and the other variables are not assigned.
}

The chainlink price data feed returns the value of eth with 8 decimal places, but the msg.value command denominates eth in 18 decimal places. To resolve this conflict, we need to add 10 decimal places to the price value returned by chainlink:

return price * 1e10 // (price times 1 with 10 zeros.)

Price is an int256 but msg.value is a uint256. We will need to convert it via typecasting.

To make the price uint256, we'd adjust as follows:

return uint256(price * 1e10);
---------------------------------------------------------------
Now we have to convert the msg.value amount into dollars with the getConversionRate function:

function getConversionRate(uint256 ethAmount) public view return(uint256)// the function getConversionRate will take a uint256 ethAmount as input, and it's results will be returned publicly as a uint256 (result being $ price of eth) 
{
 uint256 ethPrice = getPrice();
 uint256 ethAmountInUsd = (ethPrice * ethAmount) / 1e18; // To find the ethAmountInUsd we need to take the price of a whole eth from the chainlink data feed, multiply it by the amount of eth the user sent to the smart contract, and divide it by 1*10^18 because the value returned will have 18 decimal places and we want to eliminate those for a clean answer.
 return ethAmountInUsd;
 }
 
 https://youtu.be/umepbfKp5rI