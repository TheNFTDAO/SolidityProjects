Lesson 4:
Remix FundMe
We're going to create a crowdfunding type program called FundMe where users can pay in cryptocurrency to fund a cause.
This contract will allow the owner of the contract to withdraw the funds.
A new item we'll see in this lesson is a payable function (indicated by a red button in remix)
this allows the contract in question to be sent the native gas token of the chain you're working with is.
We'll also indicate a minimum USD amount in the contract.

When writing a contract or app lay out an outline of what each contract is supposed to do.
Study the global keywordsand functions!!!!!!!!!!!!!

Whenever we transact on the blockchain, there is always a value field and usually it is sent with 0 as the value. 

When we send ethereum to another wallet, we are actually putting the amount we're sending in the value field in a transaction

To make it so a user can send value to a contract, we need to add the payable keyword as such:

function fund() public payable {}

Contracts can hold funds just like a wallet address can.

We are going to use the msg.value global function to include a number of wei sent with the message.

along with including the function that allows eth to be sent to the contract, let's include code that requires a minimum amount of eth to be sent to the contract with the require as such. We will also include code that gives a message if the transaction is reverted:

require(msg.value > 1e18, didn't send enough eth);

This means that at a minimum, for this message to interact with the contract it must send a value of 1 ethereum. And the requires plus the comma indicate if the first portion reverts, do whatever the second portion says.

1e18= 1 eth = 1*10^18 wei

-------------------------------
Reverts:

Undo any actions that have been done previously, and sends the remaining gas back to user.

Let's add some logic in to see how reverts work:

let's add in uint256 public myValue = 1; //declared at the beginning of the contract

and
myValue = myValue + 2;//within the contract.

What this does is add 2 to the myValue variable every time this contract is successfully funded.

STUDY all the transaction fields!
-----------------==========================
Integrating chainlink price feeds:
Let's say in the contract we want users to spend a minimum of 5$ instead of 1 whole ethereum.
first we'll declare the minimumUsd value at the beginning of the contract:

uint8 minimumUsd = 5;

Then we change the require msg value to our new variable:

require(msg.value >= minimumUsd, "didn't send enough eth")

now, msg.value is in terms of eth but minimum USD is in terms of dollars.
To get the value of eth in dollars, we'll need to use a chainlink price data feed:

the next step will be to convert the amount of ethereum into it's value in dollars.

first we'll create a function to get the ethereum usd price, then get the conversion rate to compare it to the payable function above to see if the minimum 5 dollar threshold was met
Just as any other contract call, when we call the contract that coordinates the chainlink eth/usd price data feed we will need to find 2 datapoints:

function getPrice public(){
	// Eth USD price contract Address: 0x694AA1769357215DE4FAC081bf1f309aDC325306
	
	// ABI: When we import/call a contract, the ABI is imported but that brings in a lot of extra unnecessary code. Instead we can call the latestround function in particular to grab the price data.
}
function getConversionRate public(){

}

There will be instances where code acts as just an interface, without any logic included within it as shown by the aggregatorv3interface that lives at https://github.com/smartcontractkit/chainlink/blob/develop/contracts/src/v0.8/interfaces/FeedRegistryInterface.sol
Think of the interface as being the remote control that has the commands, and the contract it points to (in this case the eth/usd data feed contract on sepolia) being the TV that processes and has all the components to execute the command from the remote.

If you compile the interface, it will give you the ABIs you need to interact with an address.

Next let's add a function that calls the getVersion function from the aggregator interface:

function getVersion() public view returns (uint256){
	AggregatorV3Interface(0x694AA1769357215DE4FAC081bf1f309aDC325306).version();
}

https://youtu.be/umepbfKp5rI?t=16733

-------------------------===============================--

Previously we imported a contract into another contract, but both contracts lived locally in remix. Let's replace the cumbersome interface code we copy pasted into the fundMe contract with something that works a little leaner.

importing external contracts:
we are using NAMED imports, because we only want to pull over exactly what we're using to save on gas!

import {AggregatorV3Interface} from "@chainlink/contracts/src/v0.8/shared/interfaces/AggregatorV3Interface.sol"

Now that we've imported the particular code we need, let's create a function to pull chainlink price feed data into a smart contract:

function getPrice() public {
//Address - 
//ABI - 
AggregatorV3Interface priceFeed = AggregatorV3Interface(0x694AA1769357215DE4FAC081bf1f309aDC325306)}
(, int price,,,) = priceFeed.latestRoundData() //the price variable represents the price of eth in usd. We can omit the variables we don't need, but must keep the commas from them. In doing this, we are only assigning return value to the price variable, and the other variables are not assigned.
}

The chainlink price data feed returns the value of eth with 8 decimal places, but the msg.value command denominates eth in 18 decimal places. To resolve this conflict, we need to add 10 decimal places to the price value returned by chainlink:

return price * 1e10 // (price times 1 with 10 zeros.)

Price is an int256 but msg.value is a uint256. We will need to convert it via typecasting.

To make the price uint256, we'd adjust as follows:

return uint256(price * 1e10);
---------------------------------------------------------------
Now we have to convert the msg.value amount into dollars with the getConversionRate function:

function getConversionRate(uint256 ethAmount) public view return(uint256)// the function getConversionRate will take a uint256 ethAmount as input, and it's results will be returned publicly as a uint256 (result being $ price of eth) 
{
 uint256 ethPrice = getPrice();
 uint256 ethAmountInUsd = (ethPrice * ethAmount) / 1e18; // To find the ethAmountInUsd we need to take the price of a whole eth from the chainlink data feed, multiply it by the amount of eth the user sent to the smart contract, and divide it by 1*10^18 because the value returned will have 18 decimal places and we want to eliminate those for a clean answer.
 return ethAmountInUsd;
 }
 
-------------=====================================
An important rule in solidity math is you always want to multiply before you divide, because only whole numbers work in solidity. The AI can help here.

Now that we've pulled in the real world price of eth/usd into the contract, we need to run logic that makes sure the amount being funded is greater than 5$.

To do this we'll use:

require(getConversionRate(msg.value) >= minimumUsd, "Up your money son.");

getConversionRate takes an ethAmount as input, uses the price data feed to find the value of a whole eth, then converts it to ethAmountInUsd, then checks to see if the dollar value is greater than minimumUsd. Since the value returned from getConversionRate has 18 decimal places, and we're looking for the dollar value, we need to change the math logic for minimumUsd as follows:

uint256 public minimumUsd = 5e18;//that means 5 to the 18th exponent, adding 18 decimal places to the minimum usd as well so it can be used in the contract. same as we used 1e18 earlier to add 18 decimal places to eth to find the gwei value.
-------------=========================================
Next, let's keep track of the users who sent us money in this contract:

Let's make an array of addresses called "funders" and keep track of who sends us money.

address[] public funders;

then we want to make a mapping of addresses to make it easier to figure out how much money each sender has sent:

mapping(address => uint256) public addressToAmountFunded; // associate the address of the message sender from addressToAmountFunded to a number that lets us identify which number sender it was.

then to add onto existing msg.value eth sent by each sender, we'll need to add the following:

addressToAmountFunded[msg.sender] = addressToAmountFunded[msg.sender] + msg.value; // This means we're taking the address of the message sender, looking for the array entry for that particular message sender and adding the msg.value they are funding to their existing array entry.

----------------------------------------
RECAP
Whenever we interact with a contract we need the contract and ABI

Compiling an interface lets us get the ABI we need easily, and gives us ways to interact with a contract without including all the contract logic (saves gas)

when we combine the contract address with the interface we can easily call the functions in that contract.

When working with math in solidity, decimals don't work.

you need to make sure you're using the correct number of units. gwei has 18 decimal places.

msg.sender and msg.value are known as globally available units. STUDY ALL THE GLOBALLY AVAILABLE UNITS.

