Lesson 4:
Remix FundMe
We're going to create a crowdfunding type program called FundMe where users can pay in cryptocurrency to fund a cause.
This contract will allow the owner of the contract to withdraw the funds.
A new item we'll see in this lesson is a payable function (indicated by a red button in remix)
this allows the contract in question to be sent the native gas token of the chain you're working with is.
We'll also indicate a minimum USD amount in the contract.

When writing a contract or app lay out an outline of what each contract is supposed to do.
Study the global keywordsand functions!!!!!!!!!!!!!

Whenever we transact on the blockchain, there is always a value field and usually it is sent with 0 as the value. 

When we send ethereum to another wallet, we are actually putting the amount we're sending in the value field in a transaction

To make it so a user can send value to a contract, we need to add the payable keyword as such:

function fund() public payable {}

Contracts can hold funds just like a wallet address can.

We are going to use the msg.value global function to include a number of wei sent with the message.

along with including the function that allows eth to be sent to the contract, let's include code that requires a minimum amount of eth to be sent to the contract with the require as such. We will also include code that gives a message if the transaction is reverted:

require(msg.value > 1e18, didn't send enough eth);

This means that at a minimum, for this message to interact with the contract it must send a value of 1 ethereum. And the requires plus the comma indicate if the first portion reverts, do whatever the second portion says.

1e18= 1 eth = 1*10^18 wei

-------------------------------
Reverts:

Undo any actions that have been done previously, and sends the remaining gas back to user.

Let's add some logic in to see how reverts work:

let's add in uint256 public myValue = 1; //declared at the beginning of the contract

and
myValue = myValue + 2;//within the contract.

What this does is add 2 to the myValue variable every time this contract is successfully funded.

STUDY all the transaction fields!
-----------------==========================
Integrating chainlink price feeds:
Let's say in the contract we want users to spend a minimum of 5$ instead of 1 whole ethereum.
first we'll declare the minimumUsd value at the beginning of the contract:

uint8 minimumUsd = 5;

Then we change the require msg value to our new variable:

require(msg.value >= minimumUsd, "didn't send enough eth")

now, msg.value is in terms of eth but minimum USD is in terms of dollars.
To get the value of eth in dollars, we'll need to use a chainlink price data feed:

the next step will be to convert the amount of ethereum into it's value in dollars.

first we'll create a function to get the ethereum usd price, then get the conversion rate to compare it to the payable function above to see if the minimum 5 dollar threshold was met
Just as any other contract call, when we call the contract that coordinates the chainlink eth/usd price data feed we will need to find 2 datapoints:

function getPrice public(){
	// Eth USD price contract Address: 0x694AA1769357215DE4FAC081bf1f309aDC325306
	
	// ABI: When we import/call a contract, the ABI is imported but that brings in a lot of extra unnecessary code. Instead we can call the latestround function in particular to grab the price data.
}
function getConversionRate public(){

}

https://youtu.be/umepbfKp5rI?t=16733